
## 4. Page Fault异常处理

对于第三节提到的第二个关键问题，解决的关键是page fault异常处理过程中主要涉及的函数 -- do\_pgfault。在程序的执行过程中由于某种原因（页框不存在/写只读页等）而使 CPU 无法最终访问到相应的物理内存单元，即无法完成从虚拟地址到物理地址映射时，CPU 会产生一次页错误异常，从而需要进行相应的页错误异常服务例程。这个页错误异常处理的时机就是求调页/页换入换出/处理的执行时机。当相关处理完成后，页错误异常服务例程会返回到产生异常的指令处重新执行，使得软件可以继续正常运行下去。

具体而言，当启动分页机制以后，如果一条指令或数据的虚拟地址所对应的物理页框不在内存中或者访问的类型有错误（比如写一个只读页或用户态程序访问内核态的数据等），就会发生页错误异常。产生页面异常的原因主要有：

*  目标页面不存在（页表项全为0，即该线性地址与物理地址尚未建立映射或者已经撤销)；
*  相应的物理页面不在内存中（页表项非空，但Present标志位=0，比如在swap分区或磁盘文件上)，这将在下面介绍换页机制实现时进一步讲解如何处理；
*  访问权限不符合(此时页表项P标志=1，比如企图写只读页面).

当出现上面情况之一，那么就会产生页面page fault（\#PF）异常。产生异常的线性地址存储在CR2中，并且将是page fault的产生类型保存在 error code 中，比如 bit 0 表示是否 PTE\_P为0，bit 1 表示是否 write 操作。

产生页错误异常后，CPU硬件和软件都会做一些事情来应对此事。首先页错误异常也是一种异常，所以针对一般异常的硬件处理操作是必须要做的，即CPU在当前内核栈保存当前被打断的程序现场，即依次压入当前被打断程序使用的eflags，cs，eip，errorCode；由于页错误异常的中断号是0xE，CPU把异常中断号0xE对应的中断异常服务例程的地址（vectors.S中的标号vector14处）加载到cs和eip寄存器中，开始执行中断服务例程。这时ucore开始处理异常中断，首先需要保存硬件没有保存的寄存器。在vectors.S中的标号vector14处先把中断号压入内核栈，然后再在trapentry.S中的标号\_\_alltraps处把ds、es和其他通用寄存器都压栈。自此，被打断的程序现场被保存在内核栈中。接下来，在trap.c的trap函数开始了中断服务例程的处理流程，大致调用关系为：

trap--\> trap\_dispatch--\>pgfault\_handler--\>do\_pgfault

下面需要具体分析一下do\_pgfault函数。do\_pgfault的调用关系如下图所示：

图 do\_pgfault的调用关系图

![image](../lab3_figs/image002.png)

产生页错误异常后，CPU把引起页错误异常的虚拟地址装到寄存器CR2中，并给出了出错码（tf-\>tf\_err），指示引起页错误异常的存储器访问的类型。而中断服务例程会调用页错误异常处理函数do\_pgfault进行具体处理。页错误异常处理是实现按需分页、swap in/out的关键之处。

ucore中do\_pgfault函数是完成页错误异常处理的主要函数，它根据从CPU的控制寄存器CR2中获取的页错误异常的虚拟地址以及根据
error
code的错误类型来查找此虚拟地址是否在某个VMA的地址范围内以及是否满足正确的读写权限，如果在此范围内并且权限也正确，这认为这是一次合法访问，但没有建立虚实对应关系。所以需要分配一个空闲的内存页，并修改页表完成虚地址到物理地址的映射，刷新TLB，然后调用iret中断，返回到产生页错误异常的指令处重新执行此指令。如果该虚地址不再某VMA范围内，这认为是一次非法访问。
